#ifdef GL_ES
precision mediump float;
#endif

vec3 red() {
  return vec3(1., 0., 0.);
}

vec3 green() {
  return vec3(0., 1., 0.);
}

void main() {
  float f = 1.;
  // gl_FragColor = vec4(red(), 1.0);
  // gl_FragColor = vec4(green(), 1.0);
  gl_FragColor = vec4(vec3(1., 1., 1.), 1.0);
}

/*
  glsl formatting 기능 활성화 관련 주의사항


  지금 glsl 관련 extension으로

  -WebGL GLSL Editor
  -glsl-canvas
  
  요렇게 두 개 설치했는데
  설치만 해놓으면 두 익스텐션이 formatting 관련 기능이
  서로 충돌해서 제대로 작동을 안했던 것 같음.

  이를 해결하기 위해선,
  Settings에서 glsl-canvas 의 설정으로 들어간 다음,
  Use Compact Formatter 및 Use Formatter 를 비활성화 해줘야 함.

  이걸 비활성화 해야 WebGL GLSL Editor 익스텐션의
  formatting 기능이 제대로 작동할 수 있음.

  다른 컴퓨터에서 개발 환경 설정 시 참고할 것... 
*/

/*
  셰이더 특징 및 기본 구조


  1. 다른 많은 프로그래밍 언어들이 갖고 있는 main() 함수를 갖고 있음.


  2. 셰이더의 최종 목적은 화면에 어떤 색상값을 띄울 것인가이고,
  이때, 컬러는 사전에 미리 정의된 전역변수인 gl_FragColor 에 값이 지정됨.
  
  셰이더는 이처럼 다양한 종류의 내장변수, 함수, 데이터 타입을 갖고 있음.
  gl_FragColor 역시 그러한 내장변수들 중 하나임.


  3. 셰이더의 데이터 타입

  -float, int, bool  
  다른 프로그래밍 언어와 마찬가지로 갖고 있는 데이터 타임들

  -vec2, vec3, vec4
  vec2는 float 타입을 2개 갖고 있는 데이터 타입이라고 생각하면 쉬움.
  (물론 WebGL 책에서 공부했듯 vec2는 2개의 성분을 갖는 벡터값을 표현하기 위한 타입이라는 것을 알고 있음...)

  gl_FragColor는 vec4 타입의 데이터를 할당받고 있지?
  float 데이터가 4개인 vec4를 갖는 이유는
  r, g, b, a 4개의 값을 담아내기 위한 것.

  -> 아, 화면에 띄울 색상값을 r, g, b, a로 표현하는구나
  그리고 그것을 담아내는 데이터 타입은 vec4구나


  4. 꽤 많은 상황에서 각 데이터타입 안에 담기는 magnitude (크기(?))가
  0.0 ~ 1.0 사이의 normalize 된다는 것.

  예를 들어, gl_FragColor의 r자리값에 1.0을 넣으면 빨강색이 되지만,
  1.0을 넘는 값(2.0, 3.0, 100.0, ...)을 뭘 넣어도 항상 빨강색임.

  그 이유는, 저 인자 안에 들어가는 값의 크기는 0.0 ~ 1.0으로 한정이 되기 때문에
  1.0을 넘어가는 변수 또는 0.0보다 작은 값을 아무리 넣어봤자 한도 범위를 넘어가지 못한다는 것!


  5. floating point 찍기에 굉장히 유의해야 함.

  예를 들어, float f = 1 이런 식으로
  float 데이터타입에 1이라는 정수값을 넣어버리면
  다른 프로그래밍 언어들 같은 경우 정수값을 자동으로 실수값으로 변환해서 할당하는 경우도 있지만,

  셰이더는 타입 변환에 상당히 엄격하기 때문에
  저렇게 코드를 작성해버리면
  
  'cannot convert from 'const int' to 'mediump float''
  이런 식으로 타입을 변환할 수 없다고 에러를 glsl-canvas가 띄워 줌.

  이 오류를 해결하려면, 1.0 이라고 써주거나, 1. 이라고 써줘서
  정확히 '실수값 형태로' 지정해줄 것.
  -> 점 하나 때문에 오류가 나거나 컴파일이 막히는 경우가 많으니 주의할 것!

  결론적으로, float 데이터는 절대로 int 값을 넣어주면 안되고, 
  정수값을 넣으려고 해도 항상 뒤에 . 을 붙여줄 것!
*/

/*
  GLSL로 사용자정의 함수 만들기

  vec3 red() {
    return vec3(1., 0., 0.);
  }

  이런 식으로 셰이더 내에서 사용자 정의 함수 구조를 만들 수 있음.
  
  이때, 함수명 red 앞에 붙은 vec3는 
  '해당 함수가 리턴하려는 값의 타입'을 지정한 것이고,
  실제로 해당 함수 내에서 3개의 float 값이 담긴 vec3 값을 리턴해주고 있음.


  이 함수를 main() 함수 내에서 호출하여 리턴값을 사용하는 방법도 있음.

  그냥 단순하게, 
  리턴값을 사용하고 싶은 부분에 red() 이렇게 자바스크립트 함수 호출하듯이 리턴해주면
  알아서 리턴된 vec3값이 할당되는거지.

  gl_FragColor 변수에 할당하는 vec4에다가
  vec4(red(), 1.0); 
  이렇게 red 함수를 호출하면, vec4의 r, g, b값이 들어갈 자리에
  red 함수가 리턴해주는 vec3의 3개의 float값이 알아서 할당이 되는거임.

  또는 vec4(vec3(f, f, f), 1.0) 이런 식으로
  vec3 값에 실수 3개를 넣은 다음에 바로 vec4의 성분값으로 때려줄 수도 있음.
*/